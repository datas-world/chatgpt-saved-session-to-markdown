# Copyright (C) 2025 Torsten Knodt and contributors
# GNU General Public License
# SPDX-License-Identifier: GPL-3.0-or-later

name: Auto-Create GitHub Milestones

on:
  # Manual trigger
  workflow_dispatch:
  # Tag creation
  push:
    tags:
      # Major.minor.patch semver only (no pre-release or build metadata)
      - '^\d+\.\d+\.\d+$'
  # Release/package upload
  release:
    types: [published]

permissions:
  issues: write
  contents: read

jobs:
  create-milestones:
    name: Create Next Version Milestones
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@eef61447b9ff4aafe5dcd4e0bbf5d482be7e7871 # v4.2.1
        with:
          fetch-depth: 0  # Fetch all history for tags
          
      - name: Determine version to process
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual trigger, find the latest tag/release version
            LATEST_TAG=$(git tag --list --sort=-version:refname | grep -E '^\d+\.\d+\.\d+$' | head -n1)
            if [[ -z "$LATEST_TAG" ]]; then
              echo "::error::No valid major.minor.patch tags found in repository"
              exit 1
            fi
            VERSION="$LATEST_TAG"
            echo "Found latest version from tags: $VERSION"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            VERSION="${GITHUB_REF_NAME}"
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            echo "::error::Unexpected trigger event: ${{ github.event_name }}"
            exit 1
          fi
          
          # Validate major.minor.patch format only
          if [[ ! "$VERSION" =~ ^\d+\.\d+\.\d+$ ]]; then
            echo "::error::Invalid major.minor.patch version format: $VERSION"
            exit 1
          fi
          
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Processing version: $VERSION"

      - name: Calculate next versions and create milestones
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v7.0.1
        with:
          script: |
            const version = '${{ steps.version.outputs.version }}';
            console.log(`Processing version: ${version}`);
            
            // Parse major.minor.patch version
            const match = version.match(/^(\d+)\.(\d+)\.(\d+)$/);
            if (!match) {
              core.setFailed(`Failed to parse major.minor.patch version: ${version}`);
              return;
            }
            
            const [, major, minor, patch] = match.map(Number);
            console.log(`Parsed version: ${major}.${minor}.${patch}`);
            
            // Calculate next versions
            const nextVersions = [
              `${major + 1}.0.0`,  // Next major
              `${major}.${minor + 1}.0`,  // Next minor
              `${major}.${minor}.${patch + 1}`  // Next patch
            ];
            
            console.log(`Next versions to create: ${nextVersions.join(', ')}`);
            
            // Get existing milestones
            const { data: existingMilestones } = await github.rest.issues.listMilestones({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all'
            });
            
            const existingTitles = new Set(existingMilestones.map(m => m.title));
            console.log(`Existing milestones: ${Array.from(existingTitles).join(', ')}`);
            
            // Create milestones that don't exist
            const created = [];
            const skipped = [];
            
            for (const nextVersion of nextVersions) {
              if (existingTitles.has(nextVersion)) {
                skipped.push(nextVersion);
                console.log(`Milestone already exists: ${nextVersion}`);
              } else {
                try {
                  await github.rest.issues.createMilestone({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: nextVersion,
                    description: `Release milestone for version ${nextVersion}`
                  });
                  created.push(nextVersion);
                  console.log(`Created milestone: ${nextVersion}`);
                } catch (error) {
                  console.error(`Failed to create milestone ${nextVersion}: ${error.message}`);
                }
              }
            }
            
            // Summary
            console.log(`\n=== Summary ===`);
            console.log(`Base version: ${version}`);
            console.log(`Created milestones: ${created.length > 0 ? created.join(', ') : 'none'}`);
            console.log(`Skipped milestones: ${skipped.length > 0 ? skipped.join(', ') : 'none'}`);
            
            if (created.length > 0) {
              core.summary.addHeading('ðŸŽ¯ Auto-Created Milestones');
              core.summary.addList(created.map(v => `Version ${v}`));
              await core.summary.write();
            }