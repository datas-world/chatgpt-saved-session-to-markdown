# Copyright (C) 2025 Torsten Knodt and contributors
# GNU General Public License
# SPDX-License-Identifier: GPL-3.0-or-later

name: Auto-Create GitHub Milestones

on:
  # Manual trigger
  workflow_dispatch:
  # Tag creation
  push:
    tags:
      # Major.minor.patch semver only (no pre-release or build metadata)
      - '^\d+\.\d+\.\d+$'
  # Release/package upload
  release:
    types: [published]

permissions:
  issues: write
  contents: read

jobs:
  create-milestones:
    name: Create Next Version Milestones
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@eef61447b9ff4aafe5dcd4e0bbf5d482be7e7871 # v4.2.1
        with:
          fetch-depth: 0  # Fetch all history for tags
          
      - name: Determine version to process
        id: version
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v7.0.1
        with:
          script: |
            if (context.eventName === 'workflow_dispatch') {
              // For manual trigger, merge versions from both tags and releases
              console.log('Manual trigger: discovering all versions from tags and releases');
              
              // Get all tags that match major.minor.patch format
              const { execSync } = require('child_process');
              const tagOutput = execSync('git tag --list', { encoding: 'utf-8' }).trim();
              const allTags = tagOutput ? tagOutput.split('\n') : [];
              const validTags = allTags.filter(tag => /^\d+\.\d+\.\d+$/.test(tag));
              console.log(`Found ${validTags.length} valid tags: ${validTags.join(', ')}`);
              
              // Get all releases that match major.minor.patch format
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              const validReleases = releases
                .map(release => release.tag_name)
                .filter(tag => /^\d+\.\d+\.\d+$/.test(tag));
              console.log(`Found ${validReleases.length} valid releases: ${validReleases.join(', ')}`);
              
              // Merge and deduplicate all versions
              const allVersions = [...new Set([...validTags, ...validReleases])];
              console.log(`All unique versions: ${allVersions.join(', ')}`);
              
              if (allVersions.length === 0) {
                core.setFailed('No valid major.minor.patch versions found in tags or releases');
                return;
              }
              
              // Sort versions and get the highest one
              const sortedVersions = allVersions.sort((a, b) => {
                const [aMajor, aMinor, aPatch] = a.split('.').map(Number);
                const [bMajor, bMinor, bPatch] = b.split('.').map(Number);
                
                if (aMajor !== bMajor) return bMajor - aMajor;
                if (aMinor !== bMinor) return bMinor - aMinor;
                return bPatch - aPatch;
              });
              
              const latestVersion = sortedVersions[0];
              console.log(`Latest version found: ${latestVersion}`);
              core.setOutput('version', latestVersion);
              
            } else if (context.eventName === 'push') {
              const version = context.ref.replace('refs/tags/', '');
              console.log(`Tag push trigger: ${version}`);
              
              // Validate major.minor.patch format only
              if (!/^\d+\.\d+\.\d+$/.test(version)) {
                core.setFailed(`Invalid major.minor.patch version format: ${version}`);
                return;
              }
              
              core.setOutput('version', version);
              
            } else if (context.eventName === 'release') {
              const version = context.payload.release.tag_name;
              console.log(`Release trigger: ${version}`);
              
              // Validate major.minor.patch format only
              if (!/^\d+\.\d+\.\d+$/.test(version)) {
                core.setFailed(`Invalid major.minor.patch version format: ${version}`);
                return;
              }
              
              core.setOutput('version', version);
              
            } else {
              core.setFailed(`Unexpected trigger event: ${context.eventName}`);
            }

      - name: Calculate next versions and create milestones
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v7.0.1
        with:
          script: |
            const version = '${{ steps.version.outputs.version }}';
            console.log(`Processing version: ${version}`);
            
            // Parse major.minor.patch version
            const match = version.match(/^(\d+)\.(\d+)\.(\d+)$/);
            if (!match) {
              core.setFailed(`Failed to parse major.minor.patch version: ${version}`);
              return;
            }
            
            const [, major, minor, patch] = match.map(Number);
            console.log(`Parsed version: ${major}.${minor}.${patch}`);
            
            // Calculate next versions
            const nextVersions = [
              `${major + 1}.0.0`,  // Next major
              `${major}.${minor + 1}.0`,  // Next minor
              `${major}.${minor}.${patch + 1}`  // Next patch
            ];
            
            console.log(`Next versions to create: ${nextVersions.join(', ')}`);
            
            // Get existing milestones
            const { data: existingMilestones } = await github.rest.issues.listMilestones({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all'
            });
            
            const existingTitles = new Set(existingMilestones.map(m => m.title));
            console.log(`Existing milestones: ${Array.from(existingTitles).join(', ')}`);
            
            // Create milestones that don't exist
            const created = [];
            const skipped = [];
            
            for (const nextVersion of nextVersions) {
              if (existingTitles.has(nextVersion)) {
                skipped.push(nextVersion);
                console.log(`Milestone already exists: ${nextVersion}`);
              } else {
                try {
                  await github.rest.issues.createMilestone({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: nextVersion,
                    description: `Release milestone for version ${nextVersion}`
                  });
                  created.push(nextVersion);
                  console.log(`Created milestone: ${nextVersion}`);
                } catch (error) {
                  console.error(`Failed to create milestone ${nextVersion}: ${error.message}`);
                }
              }
            }
            
            // Summary
            console.log(`\n=== Summary ===`);
            console.log(`Base version: ${version}`);
            console.log(`Created milestones: ${created.length > 0 ? created.join(', ') : 'none'}`);
            console.log(`Skipped milestones: ${skipped.length > 0 ? skipped.join(', ') : 'none'}`);
            
            if (created.length > 0) {
              core.summary.addHeading('ðŸŽ¯ Auto-Created Milestones');
              core.summary.addList(created.map(v => `Version ${v}`));
              await core.summary.write();
            }