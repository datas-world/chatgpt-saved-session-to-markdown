# Copyright (C) 2025 Torsten Knodt and contributors
# GNU General Public License
# SPDX-License-Identifier: GPL-3.0-or-later

name: Release on Tag

on:
  push:
    tags:
      # Exact semver regex from semver.org (no leading v allowed)
      - '^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$'
permissions:
  contents: write
  id-token: write
  actions: read
  packages: write

jobs:
  preflight:
    name: Preflight (CI + CodeQL must have succeeded)
    runs-on: ubuntu-latest

    steps:
      - name: Capture tag and commit
        id: meta
        run: |
          echo "tag_name=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
          echo "sha=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      - name: Require CI and CodeQL success for this commit
        id: check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        with:
          script: |
            const required = ["CI", "CodeQL"];
            const sha = "${{ steps.meta.outputs.sha }}";
            const { owner, repo } = context.repo;
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, per_page: 100, event: "push",
            });
            const missing = [];
            for (const wfName of required) {
              const ok = runs.data.workflow_runs.some(r =>
                r.name === wfName &&
                r.head_sha === sha &&
                r.status === "completed" &&
                r.conclusion === "success"
              );
              if (!ok) missing.push(wfName);
            }
            core.setOutput("missing", JSON.stringify(missing));
            if (missing.length) {
              core.setFailed(`Missing successful workflows for ${sha}: ${missing.join(", ")}`);
            }

      - name: Delete tag if preflight failed
        if: ${{ failure() }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        with:
          script: |
            const ref = "refs/tags/${{ steps.meta.outputs.tag_name }}";
            try {
              await github.rest.git.deleteRef({ owner: context.repo.owner, repo: context.repo.repo, ref });
              core.warning(`Deleted tag ${ref} due to failed preflight.`);
            } catch (e) {
              core.warning(`Could not delete tag ${ref}: ${e.message}`);
            }
            core.setFailed("Release aborted.")

  build_publish:
    name: Build & Publish
    needs: preflight
    runs-on: ubuntu-latest
    environment:
      name: release

    steps:
      - name: Checkout (full history)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c
        with:
          python-version: '3.12'

      - name: Build sdist/wheel (hatch-vcs derives version from tag)
        run: |
          python -m pip install --upgrade pip
          python -m pip install build hatchling hatch-vcs
          python -m build

      - name: Verify built version equals tag
        run: |
          TAG="${GITHUB_REF_NAME}"
          BUILT=$(python - << 'PY'
          import glob, zipfile
          from email.parser import Parser
          try:
              from importlib.metadata import version as _v
              print(_v("chatgpt-saved-session-to-markdown"))
          except Exception:
              wheel = sorted(glob.glob("dist/*.whl"))[-1]
              with zipfile.ZipFile(wheel) as z:
                  meta = [n for n in z.namelist() if n.endswith("METADATA")][0]
                  info = Parser().parsestr(z.read(meta).decode())
                  print(info.get("Version"))
          PY
          )
          echo "Tag:   $TAG"
          echo "Built: $BUILT"
          test "$BUILT" = "$TAG"

      - name: Create GitHub Release and attach artifacts
        uses: softprops/action-gh-release@6cbd405e2c4e67a21c47fa9e383d020e4e28b836
        with:
          tag_name: ${{ github.ref_name }}
          generate_release_notes: true
          files: |
            dist/*

      - name: Publish to PyPI (Trusted Publishing)
        uses: pypa/gh-action-pypi-publish@ed0c53931b1dc9bd32cbe73a98c7f6766f8a527e
        with:
          skip-existing: true

      - name: Publish to GitHub Packages (Python)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python -m pip install twine
          python -m twine upload \
            --repository-url "https://api.github.com/orgs/${{ github.repository_owner }}/packages/pypi/upload" \
            dist/*
